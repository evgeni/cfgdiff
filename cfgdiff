#!/usr/bin/env python

from __future__ import print_function

import os
import sys
import io
import argparse
import collections

PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3

if PY2:
    from cStringIO import StringIO
else:
    from io import StringIO
import difflib

if PY3:
    import configparser
else:
    import ConfigParser as configparser

import json

supported_formats = ['ini', 'json']

try:
    import yaml
    supported_formats.append('yaml')
except ImportError:
    yaml = None

try:
    import lxml.etree
    supported_formats.append('xml')
except ImportError:
    pass

try:
    import configobj
    supported_formats.append('conf')
except ImportError:
    configobj = None

usage = "usage: %prog [options] fromfile tofile"
parser = argparse.ArgumentParser()
parser.add_argument("-c", action="store_true", default=False,
                    help='Produce a context format diff (default)')
parser.add_argument("-u", action="store_true", default=False,
                    help='Produce a unified format diff')
hlp = 'Produce HTML side by side diff (can use -c and -l in conjunction)'
parser.add_argument("-m", action="store_true", default=False, help=hlp)
parser.add_argument("-n", action="store_true", default=False,
                    help='Produce a ndiff format diff')
parser.add_argument("-l", "--lines", type=int, default=3,
                    help='Set number of context lines (default 3)')
parser.add_argument('-i', '--input-format', dest='inputformat', default='ini',
                    choices=supported_formats,
                    help='parse input as ini/json/yaml [default: %(default)s]')
parser.add_argument('-r', '--recursive', dest='recursive', action='store_true',
                    default=False,
                    help='recursively compare any subdirectories found')
parser.add_argument('-N', '--new-file', dest='newfile', action="store_true",
                    default=False, help='treat absent files as empty')
parser.add_argument('fromfile')
parser.add_argument('tofile')
options = parser.parse_args()

n = options.lines


class SortedDict(collections.MutableMapping):
    __slots__ = '_data'

    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[key]

    def __setitem__(self, key, value):
        self._data[key] = value

    def __delitem__(self, key):
        del self._data[key]

    def __iter__(self):
        return iter(sorted(self._data))

    def __len__(self):
        return len(self._data)


if configobj:
    class StrippedConfigObj(configobj.ConfigObj):

        def write(self, outfile=None, section=None):
            if section is None:
                section = self
                self.initial_comment = ''
                self.final_comment = ''
            section.scalars.sort()
            section.sections.sort()
            for entry in (section.scalars + section.sections):
                section.comments[entry] = []
                section.inline_comments[entry] = ''
            if section is self:
                section = None
            return super(StrippedConfigObj, self).write(outfile, section)


class DiffBase(object):

    def __init__(self, filename):
        self.filename = filename
        self.pretty = StringIO()
        self.error = None
        if filename != '/dev/null' and os.path.getsize(filename) > 0:
            try:
                self.parse()
            except Exception as e:
                self.error = repr(e)

    def parse(self):
        pass

    def readlines(self):
        self.pretty.seek(0)
        return self.pretty.readlines()


class INIDiff(DiffBase):

    def parse(self):
        if PY3:
            self.config = configparser.RawConfigParser(allow_no_value=True,
                                                       dict_type=SortedDict,
                                                       strict=False)
        else:
            self.config = configparser.RawConfigParser(allow_no_value=True,
                                                       dict_type=SortedDict)
        self.config.read(self.filename)
        self.config.write(self.pretty)


class JSONDiff(DiffBase):

    def parse(self):
        with open(self.filename) as f:
            self.config = json.load(f)
            json.dump(self.config, self.pretty, sort_keys=True, indent=4,
                      separators=(',', ': '))


class YAMLDiff(DiffBase):

    def parse(self):
        with open(self.filename) as f:
            self.config = yaml.safe_load(f)
            yaml.safe_dump(self.config, self.pretty, default_flow_style=False,
                           indent=2)


class XMLDiff(DiffBase):

    def parse(self):
        parser = lxml.etree.XMLParser(remove_blank_text=True,
                                      remove_comments=True)
        self.config = lxml.etree.parse(self.filename, parser)
        # via https://stackoverflow.com/a/8387132/1098563
        for parent in self.config.xpath('//*[./*]'):
            parent[:] = sorted(parent, key=lambda x: x.tag)
        self.config.write(self.pretty, pretty_print=True)


class ConfigDiff(DiffBase):

    def parse(self):
        self.config = StrippedConfigObj(self.filename)
        self.config.write(self.pretty)

if options.inputformat == 'ini':
    cls = INIDiff
elif options.inputformat == 'json':
    cls = JSONDiff
elif options.inputformat == 'yaml':
    cls = YAMLDiff
elif options.inputformat == 'xml':
    cls = XMLDiff
elif options.inputformat == 'conf':
    cls = ConfigDiff

fromlist = []
tolist = []
if options.recursive and os.path.isdir(options.fromfile) and os.path.isdir(options.tofile):
    for root, _, files in os.walk(options.fromfile):
        for f in files:
            x = os.path.join(root, f)
            fromlist.append(x)
            y = os.path.join(options.tofile, os.path.relpath(x, options.fromfile))
            if os.path.exists(y):
                tolist.append(y)
            else:
                tolist.append('/dev/null')
    for root, _, files in os.walk(options.tofile):
        for f in files:
            x = os.path.join(root, f)
            if not x in tolist:
                tolist.append(x)
                y = os.path.join(options.fromfile, os.path.relpath(x, options.tofile))
                if os.path.exists(y):
                    fromlist.append(y)
                else:
                    fromlist.append('/dev/null')
elif options.recursive and (os.path.isdir(options.fromfile) or os.path.isdir(options.tofile)):
    print("cannot compare folders and files")
    sys.exit(2)
else:
    fromlist.append(options.fromfile)
    tolist.append(options.tofile)

rc = 0
for fromfile, tofile in zip(fromlist, tolist):
    if '/dev/null' in (fromfile, tofile) and not options.newfile:
        rc = 1
        if fromfile != '/dev/null':
            x = os.path.relpath(fromfile, options.fromfile)
            print('Only in %s: %s' % (options.fromfile, x))
        else:
            x = os.path.relpath(tofile, options.tofile)
            print('Only in %s: %s' % (options.tofile, x))
        continue

    fromini = cls(fromfile)
    toini = cls(tofile)

    if fromini.error:
        print("%s could not be parsed as a %s file:" % (fromfile, options.inputformat))
        print(" %s" % (fromini.error))
        print("It will be interpreted as an empty file.")
    if toini.error:
        print("%s could not be parsed as a %s file:" % (tofile, options.inputformat))
        print(" %s" % (toini.error))
        print("It will be interpreted as an empty file.")

    fromlines = fromini.readlines()
    tolines = toini.readlines()

    if options.u:
        diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile, n=n)
    elif options.n:
        diff = difflib.ndiff(fromlines, tolines)
    elif options.m:
        diff = difflib.HtmlDiff().make_file(fromlines, tolines, fromfile,
                                            tofile, context=options.c,
                                            numlines=n)
    else:
        diff = difflib.context_diff(fromlines, tolines, fromfile, tofile, n=n)

    for line in diff:
        sys.stdout.write(line)
        rc = 1
sys.exit(rc)
